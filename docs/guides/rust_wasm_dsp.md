# Compiling a Rust DSP Function to WebAssembly for React

This guide walks through exporting a Rust digital signal processing (DSP) function to WebAssembly using `wasm-pack`, then consuming it from a React + TypeScript frontend.

## 1. Prerequisites

- Rust toolchain (`rustup`, `cargo`)
- [`wasm-pack`](https://rustwasm.github.io/wasm-pack/) (`cargo install wasm-pack`)
- Node.js and a package manager such as `npm`, `yarn`, or `pnpm`
- Existing React + TypeScript project or create one with `create-react-app --template typescript`

## 2. Project Structure

```
my-dsp-wasm/
├── pkg/               # Generated by wasm-pack (added to .gitignore)
├── src/
│   └── lib.rs         # Rust DSP entry point
├── Cargo.toml
└── www/               # React app (optional colocated example)
```

## 3. Create the Rust Crate

Initialize a new library crate tailored for `cdylib` output:

```bash
cargo new my-dsp-wasm --lib
cd my-dsp-wasm
```

Edit `Cargo.toml`:

```toml
[package]
name = "my-dsp-wasm"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
wasm-bindgen = "0.2"
```

## 4. Implement and Export the DSP Function

`src/lib.rs`:

```rust
use wasm_bindgen::prelude::*;

/// Process audio samples in-place inside WebAssembly.
#[wasm_bindgen]
pub fn process(samples: &mut [f32], rate: f32, depth: f32) {
    // Example placeholder modulation using a simple tremolo.
    for (index, sample) in samples.iter_mut().enumerate() {
        let phase = (index as f32) * rate * 0.001;
        let modulation = 1.0 + depth * (phase.sin());
        *sample *= modulation;
    }
}
```

Key points:

- `#[wasm_bindgen]` exposes the function to JavaScript.
- WebAssembly supports `&mut [f32]` slices by sharing memory between Rust and JS.
- Additional stateful DSP logic can be wrapped inside structs and exported similarly.

## 5. Build the WebAssembly Package

Run `wasm-pack` to produce WebAssembly bindings and JavaScript glue code:

```bash
wasm-pack build --target bundler
```

Common targets:

- `--target bundler`: for bundlers like Vite, Webpack, CRA.
- `--target web`: plain browser `<script type="module">` usage.
- `--target nodejs`: server-side usage.

`wasm-pack` generates the `pkg/` directory containing `*.wasm`, TypeScript definitions, and JS wrappers.

## 6. Publish or Link the Package

You can publish to npm or use a local path dependency. For local development with a React app in `../frontend`, link it:

```bash
wasm-pack build --target bundler
cd pkg
npm link
cd ../../frontend
npm link my-dsp-wasm
```

Alternatively, copy the `pkg/` folder into your React project and import directly.

## 7. Use the WebAssembly Module in React (TypeScript)

Install dependencies inside the React project:

```bash
npm install --save my-dsp-wasm
```

Create a hook to load and call the DSP function, e.g. `src/hooks/useDspProcessor.ts`:

```ts
import { useEffect, useState } from "react";
import init, { process } from "my-dsp-wasm";

export function useDspProcessor() {
  const [ready, setReady] = useState(false);

  useEffect(() => {
    let canceled = false;

    init()
      .then(() => {
        if (!canceled) {
          setReady(true);
        }
      })
      .catch((error) => {
        console.error("Failed to initialize WASM DSP", error);
      });

    return () => {
      canceled = true;
    };
  }, []);

  return {
    ready,
    processBuffer(samples: Float32Array, rate: number, depth: number) {
      if (!ready) {
        throw new Error("DSP module not ready");
      }

      // wasm-bindgen can work directly with typed arrays by borrowing their memory.
      process(samples, rate, depth);
      return samples;
    },
  } as const;
}
```

Use the hook in a component:

```tsx
import { useMemo } from "react";
import { useDspProcessor } from "./hooks/useDspProcessor";

export function AudioComponent({ input }: { input: Float32Array }) {
  const { ready, processBuffer } = useDspProcessor();

  const processed = useMemo(() => {
    if (!ready) {
      return input;
    }

    const buffer = new Float32Array(input);
    return processBuffer(buffer, 5, 0.5);
  }, [input, ready, processBuffer]);

  return <span>Processed samples: {processed.slice(0, 5).join(", ")}</span>;
}
```

## 8. Automate Builds with npm Scripts

Add scripts to `package.json` (root or React project) for convenience:

```json
{
  "scripts": {
    "build:wasm": "wasm-pack build --target bundler",
    "watch:wasm": "wasm-pack build --target bundler --watch"
  }
}
```

## 9. Troubleshooting Tips

- Ensure `wasm-pack` targets match your bundler (use `--target web` for Vite's `create vite@latest --template vanilla-ts`).
- Add `"type": "module"` to `package.json` if using ECMAScript modules.
- For audio worklets, transfer the `Float32Array` to the worklet thread and call the WASM function there to avoid blocking the UI.
- Keep processing functions synchronous and allocate buffers outside the render loop to minimize GC pressure.

With these steps you can iterate on Rust DSP code, recompile with `wasm-pack`, and consume the resulting WebAssembly module directly from a TypeScript-based React frontend.
